# 内存问题越界
- 何谓内存访问越界，简单的说，你向系统申请了一块内存，在使用这块内存的时候，超出了你申请的范围。例如，你明明申请的是100字节的空间，但是你由于某种原因写入了120字节，这就是内存访问越界。内存访问越界的后果是：你的写入破坏了本不属于你的空间。
```
int a;
char b[16]="abcd";
int c;

a = 1;
c = 2;
printf("a=%d,c=%d\n", a,c);
memset(b, 0,32); //注意这里访问越界了，你只有16字节空间，却修改了32字节
//memset越界后修改了a或者c的值，不同编译器对变量在空间中顺序的安排可能有不同策略
printf("a=%d,c=%d\n", a,c);
```
- 为什么增加一个变量后程序就崩溃了：增加一个变量后，内存中变量的布局也发生了变化。如果一个内存越界破坏了一个不含指针的结构，程序虽然逻辑不对，但是不至于崩溃。但是如果增加变量后，内存访问越界破坏了一个指针，则会导致程序崩溃。
```
int a;
char b[128];
//bool c;
char* d=new char[128];
int e;

b[136] = '\0';
b[137] = '\0';
b[138] = '\0';
b[139] = '\0';
strcpy(d, "haha");
```
- 为什么有些情况越界了程序也没错：程序不是只有崩溃了才是错！你破坏了别的变量，那个变量总有被使用的时候，尽管那个变量不会导致诸如程序崩溃、报警之类的严重错误，但是其计算结果必然是错误的。这种情况甚至比程序直接崩溃还要恶劣，因为程序一旦崩溃你肯定会去查，可以在导致真正严重的问题之前就把问题解决了。而如果计算错误隐藏到很晚，你的损失就可能很大了。
- 解决办法（自己想的，网上的不太会）：1. 每次都判断数组下标有没有越界 2. 查看局部指针变量指向的地址有没有发生变化