# 红黑树

## stl中的set底层用的什么数据结构
红黑树
## 红黑树的数据结构怎么定义的
```
enum Color  
{  
          RED = 0,      //红
          BLACK = 1     //黑
};  
struct RBTreeNode  
{  
           struct RBTreeNode*left, *right, *parent;     //左指针，右指针，父节点
           int   key;       //键
           int data;        //值
           Color color;     //颜色
};
```
## 红黑树有哪些性质
1. 每个结点要么是红的，要么是黑的。
2. 根结点是黑的。
3. 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。
4. 如果一个结点是红的，那么它的俩个儿子都是黑的。
5. 对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。
## 红黑树的各种操作的时间复杂度是多少
能保证在最坏情况下，基本的操作的时间均为O（lgn）
## 红黑树相比于BST和AVL树有什么优点
1. 红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在**三次旋转**之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。
2. 相比于BST，因为红黑树可以能确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证O(logN)的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到O(N)。
3. 红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高，所以在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多，但是他们的查找效率都是O(logN)，所以红黑树应用还是高于AVL树的. 实际上插入 AVL 树和红黑树的速度取决于你所插入的数据.如果你的数据分布较好,则比较宜于采用 AVL树(例如随机产生系列数),但是如果你想处理比较杂乱的情况,则红黑树是比较快的
## 红黑树相对于哈希表，在选择使用的时候有什么依据
1. 权衡三个因素: 查找速度, 数据量, 内存使用。
2. 总体来说，hash查找速度会比map快。如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash。但若你对内存使用特别严格， 希望程序尽可能少消耗内存，那么一定要小心，hash可能会让你陷入尴尬，特别是当你的hash对象特别多时，你就更无法控制了，而且 hash的构造速度较慢。
## 如何扩展红黑树来获得比某个结点小的元素有多少个
1. size[left[x]]表示在对x为根的子树进行中序遍历时排在x之前的个数，递归调用的深度不会超过O(lgn);
2. 在每个节点添加一个size域，表示以结点 x 为根的子树的结点树的大小，则有size[x] = size[[left[x]] + size [right[x]] + 1; 
## 扩展数据结构有什么步骤
1. 选择基础数据结构
2. 确定要在基础数据结构种添加哪些信息
3. 验证可用基础数据结构上的基本修改操作来维护这些新添加的信息
4. 设计新的操作
