# 红黑树

## stl中的set底层用的什么数据结构
红黑树
## 红黑树的数据结构怎么定义的
```
enum Color  
{  
          RED = 0,      //红
          BLACK = 1     //黑
};  
struct RBTreeNode  
{  
           struct RBTreeNode*left, *right, *parent;     //左指针，右指针，父节点
           int   key;       //键
           int data;        //值
           Color color;     //颜色
};
```
## 红黑树有哪些性质
1. 每个结点要么是红的，要么是黑的。
2. 根结点是黑的。
3. 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。
4. 如果一个结点是红的，那么它的俩个儿子都是黑的。
5. 对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。
## 红黑树的各种操作的时间复杂度是多少
能保证在最坏情况下，基本的操作的时间均为O（lgn）
## 红黑树相比于BST和AVL树有什么优点
1. 红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在**三次旋转**之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。
2. 相比于BST，因为红黑树可以能确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证O(logN)的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到O(N)。
