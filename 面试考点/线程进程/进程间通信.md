# 进程间通信

>> 参考：https://linuxgazette.net/104/ramankutty.html
>> 参考：https://linuxgazette.net/105/ramankutty.html

## 基础IPC
进程间通信机制分为以下几类：
1. pipes
2. fifos
3. shared memory
4. mapped memory
5. message queues
6. sockets

## pipe
>> int pipe(int pipefd[2]);

pipe()函数创建了一个单向通道，该通道可以用来进程间通信。该函数的参数包含两个文件描述符（输入一个数组，调用该函数后数组内的值自动更新），pipefd[0]指的是管道读的一端，而pipefd[1]指的是管道写的一端。写入写一端通道的数据先缓存在内核中，直到它从读一端通道读出来。

pipe创建的单向通道在进程结束后就无效了。

## fifos(first in, first out)
>> int mkfifo(const char *pathname, mode_t mode);

mkfifo()函数创建了一个fifo文件，这个会一直存在于文件系统中。一旦创建了fifo文件，任何一个进程都能像打开一个普通文件一样对它进行读写操作。然而需要注意的是，它必须同时存在读写两端才行。程序会阻塞在read函数处一直到另一个进程进行write操作为止。

优点是不需要同步机制，它是线程安全的。

缺点是只能在一台电脑上进行这些操作。

注意：在编译两个文件fiforead.cpp和fifowrite.cpp时候，记得加-lpthread

## Shared Memory
### 共享内存四步：
- Fetching an identifier for the shared memory area - shmget (shared memory get)
- Using the identifier to get the shared memory address - shmat (shared memory attach),
- Detaching the shared memory area after use - shmdt (shared memory detach) and
- Finally using the address to control accesses, permissions, receive information and destroy the shared memory area - shmctl (shared memory control). 

>> int shmget(key_t key, size_t size, int shmflg);

shmget返回一个指向共享内存的标识符

key值未仔细研究，好像可以通过ftok函数来获得一个唯一key
size是共享内存的大小，shmflg是标志，可查资料得。
>> void *shmat(int shmid, const void *shmaddr, int shmflg);

shmat函数会将共享内存空间与调用该函数进程的地址空间连接到一起。

shmid是shmget的返回值

shmaddr参数为空时系统会自动帮我们选择一个地址来绑定共享内存空间

shmflg同shmget中的shmflg

返回值是共享内存块的地址
>> int shmdt(const void *shmaddr);

该函数将共享内存与当前与之绑定的进程解绑

调用成功返回0

>> int shmctl(int shmid, int cmd, struct shmid_ds *buf);

 对共享内存块进行相应的操作

 cmd是相应的操作，IPC_RMID宏命令的意思是：在最后一个用到该共享内存的进程detach后，该共享内存块自动释放

>> 当用户按下键之后才打开检测程序，这时候检测程序检测不到之前的按键，该怎么解决这个问题？

- /proc/sysvipc/shm文件中将会列出所有在用的共享内存。
- 共享内存是线程间通信最快的方式
- 共享内存一般是和信号量一起使用
- 与将东西存在文件中相比，共享内存要更快，因为从文件中读取数据包括：1.调用系统函数open()、read()、write()等；2.读取硬盘中的文件包括了硬件上的读写操作，这个比从内存中读取要慢得多

## Memory Mapping
- 消息映射机制处理的是将文件系统中的文件映射到内存的一部分
- 当一个文件中包含用户想要的信息，用户可以写一个函数来读取文件并同时截取想要的内容。但若需要很多次这种操作的话，会很耗时。因为读取文件包括两个操作：1.调用系统函数open()、read()、write()（会经常在用户空间、内核空间切换从而耗时）等；2.硬盘的读写操作
- 内存映射是将文件与虚拟内存的一部分或用户空间联系在一起，任何的读写操作都转化为简单的内存访问。
- 



