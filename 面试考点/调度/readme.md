# 调度策略
- 调度器(scheduler)是内核的组成部分，它为CPU决定下一步将执行哪一个线程
- 每个线程都有一个调度策略以及调度优先级（sched_priority）
- 对于普通的调度策略（SCHED_OTHER），调度优先级不需要，设为0即可
- 在实时（real-time）的调度策略中（SCHED_FIFO,SCHED_RR），调度优先级sched_priority的值在1-99之间（正如sched_priority的值暗示的，实时调度策略永远优先于普通调度策略）。
- 调度器维护一个可运行的线程的列表，每个线程都有一个sched_priority值。至于该运行执行哪一个线程，调度器会从非空列表中选择优先级最高的同时选择最靠前的线程来执行
- 调度策略将决定线程在优先级相同时以何种方式插入到链表中。
- 所有调度都是抢占式的：如果具有较高静态优先级的线程准备好运行，则当前运行的线程将被抢占并返回到其静态优先级的等待列表。
## SCHED_FIFO: 先进先出实时线程
- SCHED_FIFO使用时优先级必须要大于0
- SCHED_FIFO是一个简单的调度算法，它没有时间分片（时间分片是指一个任务执行了预先指定的时间后进入等待队列，调度器将决定下一个任务该执行哪个）
- 当SCHED_FIFO线程被一个更高优先级的线程抢占后，它将排在等待队列的第一个位置。当所有较高优先级的线程阻塞后将立即执行该SCHED_FIFO线程
- SCHED_FIFO线程会被阻塞：被I/O请求阻塞，或被更高优先级的线程抢占，或者调用sched_yield。
- 当一个FIFO线程被中断后，它被放置在一个与其优先级相关联的队列中。
- 当一个FIFO线程就绪，并且如果该线程比当前正在执行的线程具有更高的优先级时，当前正在执行的线程被抢占，具有更高优先级且就绪的FIFO线程开始执行。如果有多个线程都具有最高的优先级，则选择**等待时间最长**的线程。
## SCHED_RR：轮转实时线程
- 对于SCHED_RR类，与FIFO类类似，只是在RR策略下，每个线程都有一个时间分片与之关联。当一个RR线程在它的时间分片里执行结束后，它被挂起，然后调度器选择一个具有相同或更高优先级的实时线程运行。
- 下面举例说明两个类的区别：假设存在四个线程ABCD，共有三种优先级，其中，D>B=C>A，且B在队列中的等待时间长于C，那么:
- - 对于FIFO类，调度器的执行顺序为: D--->B--->C--->A
- - 对于RR类，调度器的执行顺序为: D--->B--->C--->B--->C--->A
- - RR类将会按照“时间片”来执行，不会考虑线程的等待时间。
## SCHED_OTHER：其他非实时线程
- 对于SCHED_OTHER类，只有当没有实时线程运行就绪时，才可以执行这个类中的线程。